#include "crypto.h"

#include <stdlib.h>

#include "output.h"

/** Maximum length of a string generated by mbedtls_strerror() **/
#define COMINIT_MBEDTLS_ERR_MAX_LEN 64

#define DER_BUFFER_SIZE 1600  ///< buffer size to hold RSAâ€‘4k key.

// Macro definition to support both MbedTLS 2 and 3 interfaces.
#if MBEDTLS_VERSION_MAJOR == 2

#define cominitMbedtlsVerify(ctx, mdAlg, hashlen, hash, sig) \
    mbedtls_rsa_rsassa_pss_verify((ctx), NULL, NULL, MBEDTLS_RSA_PUBLIC, (mdAlg), (hashlen), (hash), (sig))
#define cominitComputeSHA256(data, dataLen, dataHash) mbedtls_sha256_ret(data, dataLen, dataHash, 0);
#define cominitRsaSetPadding(pkCtx, err)                                                         \
    do {                                                                                         \
        mbedtls_rsa_set_padding(mbedtls_pk_rsa(pkCtx), MBEDTLS_RSA_PKCS_V21, MBEDTLS_MD_SHA256); \
        (err) = 0;                                                                               \
    } while (0)

#elif MBEDTLS_VERSION_MAJOR == 3

#define cominitMbedtlsVerify(ctx, mdAlg, hashlen, hash, sig) \
    mbedtls_rsa_rsassa_pss_verify((ctx), (mdAlg), (hashlen), (hash), (sig))
#define cominitComputeSHA256(data, dataLen, dataHash) mbedtls_sha256(data, dataLen, dataHash, 0);
#define cominitRsaSetPadding(pkCtx, err)                                                                 \
    do {                                                                                                 \
        (err) = mbedtls_rsa_set_padding(mbedtls_pk_rsa(pkCtx), MBEDTLS_RSA_PKCS_V21, MBEDTLS_MD_SHA256); \
    } while (0)
#else

#error "Only MbedTLS versions 2 and 3 are supported."

#endif

/** String buffer for mbedtls_strerror **/
static char cominitMbedtlsErrbuf[COMINIT_MBEDTLS_ERR_MAX_LEN];

int cominitCryptoVerifySignature(const uint8_t *data, size_t dataLen, const uint8_t *signature, const char *keyfile) {
    int err = 0;
    mbedtls_pk_context pkCtx;
    mbedtls_pk_init(&pkCtx);
    err = mbedtls_pk_parse_public_keyfile(&pkCtx, keyfile);
    if (err != 0) {
        mbedtls_strerror(err, cominitMbedtlsErrbuf, sizeof(cominitMbedtlsErrbuf));
        cominitErrPrint("Parsing of public key \'%s\' failed. %s", keyfile, cominitMbedtlsErrbuf);
        mbedtls_pk_free(&pkCtx);
        return -1;
    }
    mbedtls_pk_type_t keyType = mbedtls_pk_get_type(&pkCtx);
    if (keyType == MBEDTLS_PK_NONE) {
        cominitErrPrint("Could not get type of public key \'%s\'.", keyfile);
        mbedtls_pk_free(&pkCtx);
        return -1;
    }
    cominitInfoPrint("Keyfile \'%s\' successfully loaded.", keyfile);
    if (mbedtls_pk_can_do(&pkCtx, MBEDTLS_PK_RSA) == 0) {
        cominitErrPrint("The keyfile \'%s\' did not contain a valid RSA public key.", keyfile);
        mbedtls_pk_free(&pkCtx);
        return -1;
    }

    cominitRsaSetPadding(pkCtx, err);
    if (err != 0) {
        mbedtls_strerror(err, cominitMbedtlsErrbuf, sizeof(cominitMbedtlsErrbuf));
        cominitErrPrint("Could not set RSASSA-PSS-compatible padding for RSA context. %s", cominitMbedtlsErrbuf);
        mbedtls_pk_free(&pkCtx);
        return -1;
    }

    uint8_t dataHash[32];
    err = cominitComputeSHA256(data, dataLen, dataHash);

    if (err != 0) {
        mbedtls_strerror(err, cominitMbedtlsErrbuf, sizeof(cominitMbedtlsErrbuf));
        cominitErrPrint("Could not calculate sha256 hash of input data. %s", cominitMbedtlsErrbuf);
        mbedtls_pk_free(&pkCtx);
        return -1;
    }
    err = cominitMbedtlsVerify(mbedtls_pk_rsa(pkCtx), MBEDTLS_MD_SHA256, sizeof(dataHash), dataHash, signature);
    if (err != 0) {
        mbedtls_strerror(err, cominitMbedtlsErrbuf, sizeof(cominitMbedtlsErrbuf));
        cominitErrPrint("Signature verification failed. %s", cominitMbedtlsErrbuf);
        mbedtls_pk_free(&pkCtx);
        return -1;
    }
    mbedtls_pk_free(&pkCtx);
    return 0;
}

int cominitCreateSHA256DigestfromKeyfile(const char *keyfile, unsigned char *digest, size_t digestLen) {
    int result = EXIT_FAILURE;

    if (keyfile == NULL || digest == NULL || digestLen < SHA256_LEN) {
        cominitErrPrint("Invalid parameters");
    } else {
        mbedtls_pk_context pkCtx;
        mbedtls_pk_init(&pkCtx);
        int err = mbedtls_pk_parse_public_keyfile(&pkCtx, keyfile);
        if (err == 0) {
            unsigned char der[DER_BUFFER_SIZE] = {0};
            int derLen = mbedtls_pk_write_pubkey_der(&pkCtx, der, sizeof(der));
            if (derLen > 0) {
                const unsigned char *pubKeyDer = der + sizeof(der) - derLen;
                err = cominitComputeSHA256(pubKeyDer, (size_t)derLen, digest);
                if (err == 0) {
                    result = EXIT_SUCCESS;
                }
            }
        }
        mbedtls_pk_free(&pkCtx);
    }

    return result;
}
